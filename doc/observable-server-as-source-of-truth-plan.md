# Observable Server As Source of Truth
Having a distributed, unreliable system like a lighting iot system, there are a lot of cases to consider. Controllers can be online or offline, multiple gui clients can be accessing the data.

This document describes a strategy handle this.

The premises is that the server is the master and that clients can use observability patterns to keep synchronized through MQTT.


## Terminology

| Term | Description |
|------|-------------|
| server | nerdlights.net web server |
| controller | ESP32 lighting controller |
| client | User UI client, currently HTML, but could be a phone app |
| setpoint | Setting desired to be made to a controller's runtime state |
| actual | Response to setpoint, and value retained by controller |


## Use cases
Client requests configuration change
Configuration change comes from controller, such as user pressing a physical on/off button on the controller
Changes made at controller and from configurator
Controller refuses change from client - such as setting an unsupported animation type
Configuration change affects multiple controllers, such as setting the program for a zone.

## Connection Scenarios
- Client and controller are both online
- Controller is offline but later comes online
- Multiple clients viewing the same controller

## Nuggets
Clients should see status of controllers and whether there are pending changes
Last change should win

## Basic strategy
Use the observable pattern with settings-based approach (not commands)

### MQTT Topics
- `controllers/{device_id}/setpoints/power` - Server publishes power setpoint (retained)
- `controllers/{device_id}/actuals/power` - Controller reports actual power state (retained)
- `controllers/{device_id}/setpoints/program` - Server publishes program setpoint (retained)
- `controllers/{device_id}/actuals/program` - Controller reports actual program state (retained)
- `controllers/{device_id}/settings/configuration` - Device configuration (name, wifi, etc.) (retained)
- `controllers/{device_id}/status/statistics` - Read-only device stats (uptime, memory, etc.)

**Note**: Controllers have permission to publish to both setpoint and actual topics for their own device_id, enabling local changes (physical buttons) to be communicated through the same observable pattern.

#### Example Topic Tree (Phase 1)
```
controllers/
├── esp32_001/
│   ├── setpoints/          # NEW - Phase 1
│   │   ├── power           # Server OR controller publishes (retained)
│   │   └── program         # Server OR controller publishes (retained)
│   ├── actuals/            # NEW - Phase 1  
│   │   ├── power           # Controller publishes (retained)
│   │   └── program         # Controller publishes (retained)
│   ├── [existing topics]   # UNCHANGED - Phase 1
│   │   ├── device_name     # Keep existing format
│   │   ├── wifi_ssid       # Keep existing format
│   │   └── ...             # All other existing topics
│   └── devices/            # UNCHANGED - Phase 1
│       └── esp32_001/
│           └── status/
│               ├── uptime  # Keep existing format
│               ├── memory  # Keep existing format
│               └── ...     # All other existing status
└── esp32_002/
    ├── setpoints/          # NEW - Phase 1
    │   ├── power           # Server OR controller publishes (retained)
    │   └── program         # Server OR controller publishes (retained)
    ├── actuals/            # NEW - Phase 1
    │   ├── power           # Controller publishes (retained)
    │   └── program         # Controller publishes (retained)
    └── [existing topics]   # UNCHANGED - Phase 1
```

**Topic Usage Comments (Phase 1):**
- **NEW: Setpoints/Actuals**: Only for power and program control using observable pattern
- **UNCHANGED: All existing topics**: Device configuration, status, statistics remain as-is
- **Server-initiated changes**: Server publishes to NEW setpoint topics when clients request power/program changes
- **Controller-initiated changes**: Controller publishes to BOTH NEW setpoint and actual topics for physical button presses
- **Backward compatibility**: All existing MQTT topics and HTTP routes continue to work unchanged
- **Gradual migration**: Only power/program operations use the new observable pattern

### Message Format
Each settings message includes a unique ID generated by the originator (client or controller). Since device IDs are unique, ID collisions are avoided through proper generation by clients and controllers.

**Power Messages:**
```json
{
  "id": "client_12345_1699084200",
  "timestamp": "2025-11-04T10:30:00Z",
  "lights_on": true
}
```

**Program Messages:**
```json
{
  "id": "client_67890_1699084201", 
  "timestamp": "2025-11-04T10:30:01Z",
  "program": {
    "light_mode": "gradient",
    "brightness": 128,
    "colors": [{"r": 255, "g": 0, "b": 0}]
  }
}
```

### Controller Logic
- Track last actual ID for each setting type (power, program)
- On receiving setpoint power: if setpoint.id != last_actual_power.id, apply and report, remembering the id
- On receiving setpoint program: if setpoint.id != last_actual_program.id, apply and report, remember
- Physical button press sets the setpoint and actuals for power
- Settings are idempotent - same setpoint can be applied multiple times safely

### Server Logic
The server acts as the central coordinator and primary source of truth:

- **Client Requests**: When clients make changes, server validates and publishes setpoint messages
- **State Tracking**: Server can subscribe to actual topics to track controller states
- **Error Handling**: Controllers report errors once, then it's up to users to retry
- **Zone Coordination**: Server decomposes zone commands into individual controller setpoints
- **Authority**: Server-published setpoints take precedence over controller-initiated changes when both exist

**Note**: Detailed server implementation logic should be documented separately in architecture documentation.

### Client Logic
- Generate unique ID when making requests (e.g., `client_{random}_{timestamp}`)
- Power changes go to power topics, program changes go to program topics
- Subscribe to both setpoint and actual topics for complete state
- **UI Display Strategy**: Always show setpoint values as the "intended state"
- **Calculate Status**: Show pending until actual.id matches setpoint.id for each setting type
- **Error Detection**: Show error state if actual.status == "error"
- **Server Communication**: Server handles translating client requests to MQTT setpoint messages

### Error Handling
Controllers report errors and always include the full applied state in actual messages. The system follows a "try once" approach - controllers attempt to apply setpoints once and report the result. Users must manually retry if needed.

```json
{
  "id": "unique_id_123",
  "status": "error",
  "error": "unsupported_light_mode", 
  "timestamp": "2025-11-04T10:30:02Z",
  "lights_on": true,
  "program": {
    "light_mode": "solid",
    "brightness": 128,
    "colors": [{"r": 255, "g": 0, "b": 0}]
  }
}
```

**Error Recovery**: Controllers do not automatically retry failed operations. Users must initiate new requests to retry failed changes.

### Benefits
- No sequence number tracking needed
- Resilient to network failures - controller gets latest state on reconnect
- Idempotent operations
- Clear pending/error state visibility for clients
- Controllers can make local changes while maintaining server authority

### Physical Button / Local Changes
Controllers can make local changes (physical buttons, sensors, etc.) and these should always immediately change the actual power state. When a physical button is pressed:

1. **Immediate Action**: Controller immediately changes its power state
2. **Server Communication**: When online, controller attempts to publish to both setpoint and actual topics so all clients see the change
3. **Offline Reconciliation**: If offline when pressed, the change will be reconciled when connection resumes - controller will see if there are newer setpoint settings and adopt server's state as source of truth
4. **Persistence**: Physical changes persist until overridden by newer setpoint settings from server

## Competing Changes Behavior

**Scenario 1**: Controller offline → user presses physical button (lights OFF) → client changes setting (lights ON) → controller reconnects

**Result**: Client wins. Physical button change is lost because:
1. Controller can't publish change while offline
2. When reconnecting, controller sees newer setpoint settings from retained MQTT messages
3. Controller adopts server's state as source of truth

**Scenario 2**: Controller offline → user presses physical button (lights OFF) → controller reconnects (no client changes)

**Result**: Physical button change persists. Controller sees no new setpoint settings (same IDs as before), so keeps local state and publishes current state to actual topics. UI will then reflect the actual controller state.

This maintains "server as source of truth" principle - any changes not communicated through the server are overridden by the last server-published state.

## Zone Coordination (TBD)

Zones commands are deconstructed at the server into commands to individual controllers.  The server must also aggregate responses. Servers always receive full commands / full programs.

- All controllers in zone attempt to apply the setpoint
- All controllers publish their individual actual responses
- Client/server logic aggregates actual responses to determine overall zone state
- Zone is considered "applied" when all controllers report successful application
- Zone shows "error" state if any controller reports an error
- Zone shows "pending" if any controller hasn't responded yet


## Implementation Notes

### Phase 1: Setpoints/Actuals Only (Limited Scope)
For the initial implementation, we'll only implement the observable pattern for operational state:

**Phase 1 Scope:**
- `controllers/{device_id}/setpoints/power` - Server publishes power setpoint (retained)
- `controllers/{device_id}/actuals/power` - Controller reports actual power state (retained)  
- `controllers/{device_id}/setpoints/program` - Server publishes program setpoint (retained)
- `controllers/{device_id}/actuals/program` - Controller reports actual program state (retained)

**Phase 1 Exclusions:**
- Keep existing topics for settings/configuration (device name, wifi, etc.)
- Keep existing topics for status/statistics (uptime, memory, etc.)
- No changes to current HTTP API routes - server maps existing routes to new MQTT topics

**Phase 1 Benefits:**
- Focused implementation scope
- Observable pattern for most critical operations (power/program control)
- Backward compatibility maintained for less critical features
- Server can internally bridge old API routes to new MQTT setpoint topics

### Phase 2: Complete Migration (Future)
- Migrate settings/configuration to new topic structure
- Update HTTP API routes to match new topic organization
- Migrate status/statistics to standardized format

### Phase 2: Client Updates (TBD - Don't implement yet)
For phase 1, we should be able to use the existing routes and map it to new MQTT endpoints.

Current HTTP routes will be replaced with new structure:

**Current Routes:**
- `POST /apis/lights_on`
- `POST /apis/lights_off` 
- `POST /apis/send`
- `GET /apis/controllers`

**Future Routes (TBD - need to decide on structure):**
Option A: `POST /apis/controllers/{device_id}/settings/power`
Option B: `POST /user/strands/{id}/power`

**Current MQTT Topics:**
- Subscribes to: `devices/+/status/+`
- Publishes to: `{controller_id}` (bare device ID)
- Message format: `{cmd:"on"}`

**New MQTT Topics:**
- Publishes to: `controllers/{device_id}/setpoints/power`
- Publishes to: `controllers/{device_id}/setpoints/program`
- Subscribes to: `controllers/{device_id}/actuals/+` and `controllers/{device_id}/status/+`
- Message format: `{id:"...", lights_on:true}`

## Required Documentation Updates

If this plan is adopted, the following documentation files will need updates:

### Critical Updates Required:
1. **`mqtt-topics.md`** - Complete rewrite of topic structure and message formats
2. **`api-routes.md`** - Update all controller-related endpoints to new structure
3. **`architecture.md`** - Update MQTT topic structure section and data flow diagrams

### Secondary Updates:
4. **`database-schema.md`** - May need updates if new fields are required for tracking setpoint/actual states
5. **`developer-setup.md`** - Update any examples using old MQTT topics or API routes
6. **`migration-plan.md`** - Update or replace with new implementation timeline
7. **`design-nuggets.md`** - Update any references to old communication patterns

### Testing Documentation:
8. Update any debugging examples in `mqtt-topics.md` using mosquitto_pub/sub commands
9. Update client-side WebSocket subscription examples in relevant files
10. Update any controller setup documentation with new topic requirements

## Controller Pseudocode

```
// State variables
last_actual_power_id = ""
last_actual_program_id = ""
current_power_state = true
current_program = {default_program}
initial_sync_complete = false
pending_power_sync = true
pending_program_sync = true

// On MQTT connection/reconnection
function on_mqtt_connect():
    // Reset sync flags
    initial_sync_complete = false
    pending_power_sync = true
    pending_program_sync = true
    
    subscribe("controllers/{device_id}/setpoints/power")
    subscribe("controllers/{device_id}/setpoints/program")
    
    // Start timeout to handle case where no retained messages exist
    // We can't distinguish between "no retained messages" and "server unavailable"
    // but timeout allows us to proceed with current state if no messages arrive
    start_retained_message_timeout(RETAINED_MESSAGE_TIMEOUT_MS)
    
    // MQTT will deliver retained messages immediately after subscribe
    // Our setpoint handlers will process them and clear the pending flags
    // Once both are processed (or timeout expires), publish actual state

// On receiving setpoint power settings
function on_power_setpoint_received(message):
    pending_power_sync = false  // Mark power sync as complete
    
    if message.id != last_actual_power_id:
        // Apply the new power setting
        current_power_state = message.lights_on
        apply_power_setting(current_power_state)
        
        // Report what we actually applied
        last_actual_power_id = message.id
        publish_actual_power(message.id, "applied")
    
    check_initial_sync_complete()

// On receiving setpoint program settings  
function on_program_setpoint_received(message):
    pending_program_sync = false  // Mark program sync as complete
    
    if message.id != last_actual_program_id:
        try:
            // Validate and apply program
            validate_program(message.program)
            current_program = message.program
            apply_program_setting(current_program)
            
            // Report success
            last_actual_program_id = message.id
            publish_actual_program(message.id, "applied")
        catch validation_error:
            // Report error with fallback program
            current_program = get_fallback_program()
            apply_program_setting(current_program)
            last_actual_program_id = message.id
            publish_actual_program(message.id, "error", validation_error)
    
    check_initial_sync_complete()

// On retained message timeout
function on_retained_message_timeout():
    // If we haven't received retained messages by timeout, assume none exist
    // Note: We cannot distinguish between "no retained messages" and "server unavailable"
    // but we proceed with current state to avoid indefinite blocking
    if pending_power_sync:
        pending_power_sync = false
    if pending_program_sync:
        pending_program_sync = false
    check_initial_sync_complete()

// On physical button press
function on_physical_button_press():
    // Always immediately change the power state
    current_power_state = !current_power_state
    apply_power_setting(current_power_state)
    
    // Try to communicate with server if online
    if mqtt_connected():
        // Generate unique controller ID
        unique_id = "controller_{device_id}_{timestamp}"
        last_actual_power_id = unique_id
        
        // Publish BOTH setpoint and actual so all clients see the change
        // If this fails, it will be reconciled when connection resumes
        publish_setpoint_power(unique_id)
        publish_actual_power(unique_id, "applied")

// Helper functions
function check_initial_sync_complete():
    // Only publish initial state once we've processed all retained messages
    if !initial_sync_complete && !pending_power_sync && !pending_program_sync:
        initial_sync_complete = true
        // Publish current actual state (which may have been updated by server setpoints)
        publish_actual_power(last_actual_power_id, "applied")
        publish_actual_program(last_actual_program_id, "applied")

function publish_setpoint_power(id):
    message = {
        "id": id,
        "timestamp": current_timestamp(),
        "lights_on": current_power_state
    }
    publish("controllers/{device_id}/setpoints/power", message, retained=true)

function publish_actual_power(id, status="applied", error=null):
    message = {
        "id": id,
        "status": status,
        "timestamp": current_timestamp(),
        "lights_on": current_power_state
    }
    if error:
        message.error = error
    publish("controllers/{device_id}/actuals/power", message, retained=true)

function publish_actual_program(id, status="applied", error=null):
    message = {
        "id": id, 
        "status": status,
        "timestamp": current_timestamp(),
        "lights_on": current_power_state,  // Always include full state
        "program": current_program
    }
    if error:
        message.error = error
    publish("controllers/{device_id}/actuals/program", message, retained=true)
```

## Controller Implementation Changes (nerd-lights folder)

### Overview
The ESP32 controller code needs to implement the observable pattern for power and program setpoints/actuals while maintaining backward compatibility with existing functionality.

### Required Code Changes

#### 1. MQTT Topic Subscription Updates
**File: `src/mqtt.cpp` (or equivalent MQTT handling file)**

Add new topic subscriptions:
```cpp
// Add to existing MQTT connection setup
void setupMqttSubscriptions() {
    // Existing subscriptions remain unchanged
    // ...existing code...
    
    // NEW: Subscribe to setpoint topics
    String powerSetpointTopic = "controllers/" + String(deviceId) + "/setpoints/power";
    String programSetpointTopic = "controllers/" + String(deviceId) + "/setpoints/program";
    
    mqttClient.subscribe(powerSetpointTopic.c_str());
    mqttClient.subscribe(programSetpointTopic.c_str());
}
```

#### 2. Message Handling Updates
**File: `src/mqtt.cpp`**

Add handlers for new setpoint messages:
```cpp
void onMqttMessage(char* topic, byte* payload, unsigned int length) {
    // ...existing message handling...
    
    String topicStr = String(topic);
    String devicePrefix = "controllers/" + String(deviceId) + "/setpoints/";
    
    if (topicStr.startsWith(devicePrefix)) {
        String settingType = topicStr.substring(devicePrefix.length());
        
        if (settingType == "power") {
            handlePowerSetpoint(payload, length);
        } else if (settingType == "program") {
            handleProgramSetpoint(payload, length);
        }
    }
    
    // Keep existing message handling for backward compatibility
}
```

#### 3. State Management Variables
**File: `src/main.cpp` or appropriate state file**

Add new state tracking variables:
```cpp
// NEW: Observable pattern state tracking
String lastActualPowerId = "";
String lastActualProgramId = "";
bool initialSyncComplete = false;
bool pendingPowerSync = true;
bool pendingProgramSync = true;
unsigned long retainedMessageTimeout = 5000; // 5 second timeout
unsigned long syncStartTime = 0;

// Existing state variables remain unchanged
bool lightsOn = true;
// ...existing program state...
```

#### 4. Setpoint Handlers
**File: `src/mqtt.cpp` or new file `src/observable.cpp`**

```cpp
void handlePowerSetpoint(byte* payload, unsigned int length) {
    pendingPowerSync = false;
    
    // Parse JSON message
    DynamicJsonDocument doc(1024);
    deserializeJson(doc, payload, length);
    
    String messageId = doc["id"];
    
    if (messageId != lastActualPowerId) {
        bool requestedState = doc["lights_on"];
        
        // Apply the power setting
        lightsOn = requestedState;
        applyPowerState(lightsOn);
        
        // Report what we applied
        lastActualPowerId = messageId;
        publishActualPower(messageId, "applied");
    }
    
    checkInitialSyncComplete();
}

void handleProgramSetpoint(byte* payload, unsigned int length) {
    pendingProgramSync = false;
    
    // Parse JSON message
    DynamicJsonDocument doc(1024);
    deserializeJson(doc, payload, length);
    
    String messageId = doc["id"];
    
    if (messageId != lastActualProgramId) {
        // Extract program data
        JsonObject programObj = doc["program"];
        
        // Validate and apply program
        if (validateProgram(programObj)) {
            applyProgram(programObj);
            lastActualProgramId = messageId;
            publishActualProgram(messageId, "applied");
        } else {
            // Apply fallback program and report error
            applyFallbackProgram();
            lastActualProgramId = messageId;
            publishActualProgram(messageId, "error", "invalid_program");
        }
    }
    
    checkInitialSyncComplete();
}
```

#### 5. Publishing Functions
**File: `src/mqtt.cpp`**

```cpp
void publishActualPower(String messageId, String status, String error = "") {
    DynamicJsonDocument doc(512);
    doc["id"] = messageId;
    doc["status"] = status;
    doc["timestamp"] = getCurrentTimestamp();
    doc["lights_on"] = lightsOn;
    
    if (error.length() > 0) {
        doc["error"] = error;
    }
    
    String topic = "controllers/" + String(deviceId) + "/actuals/power";
    String payload;
    serializeJson(doc, payload);
    
    mqttClient.publish(topic.c_str(), payload.c_str(), true); // retained=true
}

void publishActualProgram(String messageId, String status, String error = "") {
    DynamicJsonDocument doc(1024);
    doc["id"] = messageId;
    doc["status"] = status;
    doc["timestamp"] = getCurrentTimestamp();
    doc["lights_on"] = lightsOn;
    
    // Include full program state
    JsonObject programObj = doc.createNestedObject("program");
    serializeCurrentProgram(programObj);
    
    if (error.length() > 0) {
        doc["error"] = error;
    }
    
    String topic = "controllers/" + String(deviceId) + "/actuals/program";
    String payload;
    serializeJson(doc, payload);
    
    mqttClient.publish(topic.c_str(), payload.c_str(), true); // retained=true
}
```

#### 6. Physical Button Integration
**File: `src/button.cpp` or wherever button handling exists**

```cpp
void onPhysicalButtonPress() {
    // Immediately change power state
    lightsOn = !lightsOn;
    applyPowerState(lightsOn);
    
    // Communicate change to server if online
    if (mqttClient.connected()) {
        String uniqueId = "controller_" + String(deviceId) + "_" + String(millis());
        lastActualPowerId = uniqueId;
        
        // Publish both setpoint and actual
        publishSetpointPower(uniqueId);
        publishActualPower(uniqueId, "applied");
    }
}

void publishSetpointPower(String messageId) {
    DynamicJsonDocument doc(512);
    doc["id"] = messageId;
    doc["timestamp"] = getCurrentTimestamp();
    doc["lights_on"] = lightsOn;
    
    String topic = "controllers/" + String(deviceId) + "/setpoints/power";
    String payload;
    serializeJson(doc, payload);
    
    mqttClient.publish(topic.c_str(), payload.c_str(), true); // retained=true
}
```

#### 7. Connection Management
**File: `src/mqtt.cpp`**

```cpp
void onMqttConnect() {
    // ...existing connection logic...
    
    // Reset sync state
    initialSyncComplete = false;
    pendingPowerSync = true;
    pendingProgramSync = true;
    syncStartTime = millis();
    
    setupMqttSubscriptions();
    
    // MQTT will deliver retained messages after subscription
    // Our handlers will process them and update sync flags
}

void checkInitialSyncComplete() {
    if (!initialSyncComplete && !pendingPowerSync && !pendingProgramSync) {
        initialSyncComplete = true;
        
        // Publish current actual state
        publishActualPower(lastActualPowerId, "applied");
        publishActualProgram(lastActualProgramId, "applied");
    }
}

// Add to main loop
void loop() {
    // ...existing loop code...
    
    // Check for retained message timeout
    if (!initialSyncComplete && 
        (pendingPowerSync || pendingProgramSync) &&
        (millis() - syncStartTime > retainedMessageTimeout)) {
        
        pendingPowerSync = false;
        pendingProgramSync = false;
        checkInitialSyncComplete();
    }
}
```

### Files That Need Changes
1. **`src/mqtt.cpp`** - Add new topic subscriptions and message handlers
2. **`src/main.cpp`** - Add state tracking variables
3. **`src/button.cpp`** - Update physical button handling
4. **New file: `src/observable.cpp`** - Implement observable pattern logic
5. **`src/config.h`** - Add any new configuration constants

### Backward Compatibility
- Keep all existing MQTT topic handling unchanged
- Maintain existing HTTP/WebSocket functionality
- Add new observable pattern alongside existing code
- No breaking changes to current controller behavior

### Testing Requirements
- Test setpoint message handling with various JSON formats
- Test physical button behavior with and without MQTT connection
- Test retained message handling on reconnection
- Test error handling for invalid program data
- Verify memory usage doesn't exceed ESP32 limits

### Implementation Notes
- Use retained messages for all setpoint/actual publications
- Implement proper JSON validation to prevent crashes
- Add timeout handling for initial sync to avoid indefinite blocking
- Generate unique message IDs using device ID + timestamp
- Always include full state in actual messages for debugging